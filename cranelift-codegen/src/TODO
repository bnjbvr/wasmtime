TODO:

- Function ABI:
  - callee side
    - Arguments and return values
    - Prologue and epilogue generation
  - caller side
    - Clobbers, function args, etc.

  - alloca? explicit spillslot / stackslot instructions?
  - fixup pass after regalloc, when we know how large the frame is (or just make all
    references relative to FP)

- Binary emission
  - Constant pool? Need MemArg resolution just prior to emission (when we know
    the constant-pool offset)

- ISA completeness:
  - ImmLogic: implement the algorithm to determine whether an immediate can be
    encoded as a logical immediate.
  - Add opcodes to lowering. ALU, loads/stores, control flow. All integer
    instruction set.
  - 8/16-bit ops? Widening for legalization?

- Post-MVP:

  - better block reordering: heuristically place after `from` or before `to` if
    only one out-edge or in-edge respectively (?). Or split the compound
    condbr/br and put one crit edge between the branches.

  - VCode (re)design:
    - allow edits (insertions, deletions, block reorder) alongside instruction list
    - rework lowering and VCodeBuilder: single forward pass; delete insns when
      unused

  - VCode as arch-independent input:
    - side-table: single-def for a given register use?
    - put Cranelift IR opcodes/instructions into VCode container

  - Handle out-of-range branches and constant-pool references (out of imm19
    range at least)

-------


Milestones:

- M0: codegen a leaf function (no calls) with only integer add/sub, load/store,
  and control flow. No prologue or epilogue.

- M1: function ABI. Support function arguments and return value. Save clobbered
  registers. Support calls to other functions, saving caller-saved regs.

- M2: fill out the integer instruction set. Support all Cranelift ops that are
  not FP or vector-related.

- M3: full Cranelift instruction set support.
