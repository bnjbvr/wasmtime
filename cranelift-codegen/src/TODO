TODO:

- Work out branch lowering, critical edge splits, and machine-independent handling of phis.

  - machinst/lower, isa/arm64: Compute instruction sizes and resolve block
    offsets and branch relos.
    - Compute maximum size of all instructions, and block offsets.
    - Given block offsets, allow each branch to use a smaller form. Compute final offsets.
    - Resolve branch targets to concrete values. (All machine instructions
      should have an enum with options: BlockIndex, usize.)

- Finish top-level compilation pipeline
  - Integration with regalloc (call minira)
  - Prologue and epilogue generation
  - Binary emission driver
    - Constant pool handling? Alignment?

- ISA completeness:

  - ImmLogic: implement the algorithm to determine whether an immediate can be
    encoded as a logical immediate.

  - Add opcodes to lowering. ALU, loads/stores, control flow.

  - 8/16-bit ops? Widening for legalization?

- Work out how to fit this into Cranelift public API.

-------


Milestones:

- M0: codegen a leaf function (no calls) with only integer add/sub, load/store,
  and control flow. No prologue or epilogue.

- M1: function ABI. Support function arguments and return value. Save clobbered
  registers. Support calls to other functions, saving caller-saved regs.

- M2: fill out the integer instruction set. Support all Cranelift ops that are
  not FP or vector-related.

- M3: full Cranelift instruction set support.
